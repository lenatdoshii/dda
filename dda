#!/usr/bin/env bash
#
# dda
# Interactive tool for viewing GitHub Dependabot alerts for an organization
#

set -euo pipefail

# ═══════════════════════════════════════════════════════════════════════════════
# CONFIGURATION
# ═══════════════════════════════════════════════════════════════════════════════

if [ -z "${GITHUB_ORG:-}" ]; then
  echo -e "\033[0;31mERROR:\033[0m GITHUB_ORG environment variable is not set." >&2
  echo -e "       Set it to your GitHub organization name, e.g.:" >&2
  echo -e "       export GITHUB_ORG=my-organization" >&2
  exit 1
fi

ORG="${GITHUB_ORG}"
GITHUB_API_VERSION="2022-11-28"

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# ═══════════════════════════════════════════════════════════════════════════════
# HELP
# ═══════════════════════════════════════════════════════════════════════════════

show_help() {
  cat <<EOF
${BOLD}dependabot-alerts.sh${NC} - Interactive Dependabot Alert Viewer

${BOLD}DESCRIPTION${NC}
    An interactive tool for viewing GitHub Dependabot security alerts for a
    GitHub organization. Browse repositories with active alerts, view alert
    details, and copy formatted alert information to your clipboard.

${BOLD}ENVIRONMENT${NC}
    GITHUB_ORG          (required) The GitHub organization to query alerts for.
                        Example: export GITHUB_ORG=my-organization

${BOLD}USAGE${NC}
    ./dependabot-alerts.sh [OPTIONS]

${BOLD}OPTIONS${NC}
    -h, --help              Show this help message and exit
    -r, --repo REPO         Specify repository name (skips repo selection)
    -a, --alert NUMBER      Specify alert number (requires --repo)

${BOLD}MODES${NC}
    Interactive (default):
        Run without arguments to interactively browse and select alerts.
        Selected alert is copied to clipboard automatically.

    Repository summary (--repo only):
        Outputs a markdown table of all alerts for the specified repo.
        Suitable for quick overview or piping to other tools.

    Single alert (--repo and --alert):
        Outputs detailed alert information in markdown format.
        Suitable for piping: ./dependabot-alerts.sh -r myrepo -a 123 | pbcopy

${BOLD}DEPENDENCIES${NC}
    - gh      GitHub CLI (must be authenticated)
    - fzf     Fuzzy finder for interactive selection (not needed with --repo --alert)
    - jq      JSON processor

${BOLD}KEYBOARD SHORTCUTS (fzf)${NC}
    Enter     Select item
    Ctrl+C    Cancel/Exit
    ↑/↓       Navigate list
    Type      Filter results

${BOLD}EXAMPLES${NC}
    # Run fully interactively
    ./dependabot-alerts.sh

    # List all alerts for a specific repo (markdown table)
    ./dependabot-alerts.sh --repo my-service

    # Output specific alert details (markdown)
    ./dependabot-alerts.sh --repo my-service --alert 42

    # Copy specific alert to clipboard
    ./dependabot-alerts.sh -r my-service -a 42 | pbcopy

${BOLD}OUTPUT FORMAT${NC}
    Alert details are output in Markdown format, including:
    - Package name and ecosystem
    - Severity level and CVE/GHSA identifiers
    - Vulnerability description
    - Affected versions
    - Fix information (if available)
    - Links to the alert and advisory

EOF
}

# ═══════════════════════════════════════════════════════════════════════════════
# UTILITY FUNCTIONS
# ═══════════════════════════════════════════════════════════════════════════════

error() {
  echo -e "${RED}ERROR:${NC} $1" >&2
  exit 1
}

warn() {
  echo -e "${YELLOW}WARNING:${NC} $1" >&2
}

info() {
  echo -e "${BLUE}INFO:${NC} $1" >&2
}

success() {
  echo -e "${GREEN}SUCCESS:${NC} $1" >&2
}

# Severity color coding
severity_color() {
  local severity="$1"
  case "${severity,,}" in
  critical) echo -e "${RED}${BOLD}CRITICAL${NC}" ;;
  high) echo -e "${RED}HIGH${NC}" ;;
  medium) echo -e "${YELLOW}MEDIUM${NC}" ;;
  low) echo -e "${GREEN}LOW${NC}" ;;
  *) echo "$severity" ;;
  esac
}

# ═══════════════════════════════════════════════════════════════════════════════
# DEPENDENCY CHECKS
# ═══════════════════════════════════════════════════════════════════════════════

check_dependencies() {
  local interactive="${1:-true}"
  local missing=()

  if ! command -v gh &>/dev/null; then
    missing+=("gh (GitHub CLI)")
  fi

  # fzf only needed for interactive mode
  if [ "$interactive" = "true" ] && ! command -v fzf &>/dev/null; then
    missing+=("fzf (fuzzy finder)")
  fi

  if ! command -v jq &>/dev/null; then
    missing+=("jq (JSON processor)")
  fi

  if [ ${#missing[@]} -ne 0 ]; then
    error "Missing required dependencies:\n  - ${missing[*]}\n\nInstall with: brew install gh fzf jq"
  fi

  # Check gh authentication
  if ! gh auth status &>/dev/null; then
    error "GitHub CLI is not authenticated. Run: gh auth login"
  fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# API FUNCTIONS
# ═══════════════════════════════════════════════════════════════════════════════

fetch_org_alerts() {
  info "Fetching Dependabot alerts for ${CYAN}${ORG}${NC}..."

  # Use --paginate to fetch all alerts (not just first 100)
  gh api \
    --paginate \
    -H "Accept: application/vnd.github+json" \
    -H "X-GitHub-Api-Version: ${GITHUB_API_VERSION}" \
    "/orgs/${ORG}/dependabot/alerts?state=open&per_page=100" 2>/dev/null |
    jq -s 'add' # Combine paginated arrays into single array
}

fetch_repo_alerts() {
  local repo="$1"
  local quiet="${2:-false}"

  # Use --paginate to fetch all alerts (not just first 100)
  gh api \
    --paginate \
    -H "Accept: application/vnd.github+json" \
    -H "X-GitHub-Api-Version: ${GITHUB_API_VERSION}" \
    "/repos/${ORG}/${repo}/dependabot/alerts?state=open&per_page=100" 2>/dev/null |
    jq -s 'add' # Combine paginated arrays into single array
}

# ═══════════════════════════════════════════════════════════════════════════════
# DATA PROCESSING
# ═══════════════════════════════════════════════════════════════════════════════

# Extract unique repos with alert counts
get_repos_with_counts() {
  local alerts_json="$1"

  printf '%s\n' "$alerts_json" | jq -r '
        group_by(.repository.name) | 
        map({
            repo: .[0].repository.name,
            total: length,
            critical: [.[] | select(.security_advisory.severity == "critical")] | length,
            high: [.[] | select(.security_advisory.severity == "high")] | length,
            medium: [.[] | select(.security_advisory.severity == "medium")] | length,
            low: [.[] | select(.security_advisory.severity == "low")] | length
        }) |
        sort_by(-.critical, -.high, -.total) |
        .[] |
        "\(.repo)|\(.total)|\(.critical)|\(.high)|\(.medium)|\(.low)"
    '
}

# Format repo line for display
format_repo_line() {
  local line="$1"
  local repo total critical high medium low

  IFS='|' read -r repo total critical high medium low <<<"$line"

  local severity_info=""
  [ "$critical" -gt 0 ] && severity_info+="${RED}${critical} critical${NC} "
  [ "$high" -gt 0 ] && severity_info+="${YELLOW}${high} high${NC} "
  [ "$medium" -gt 0 ] && severity_info+="${BLUE}${medium} medium${NC} "
  [ "$low" -gt 0 ] && severity_info+="${GREEN}${low} low${NC}"

  printf "${BOLD}%-40s${NC} ${MAGENTA}(%d alerts)${NC} %b\n" "$repo" "$total" "$severity_info"
}

# Format alert summaries for fzf
format_alert_summaries() {
  local alerts_json="$1"

  printf '%s\n' "$alerts_json" | jq -r '
        .[] |
        "\(.number)|\(.security_advisory.severity // "unknown")|\(.security_vulnerability.package.name)|\(.security_advisory.cve_id // .security_advisory.ghsa_id)|\(.security_advisory.summary | gsub("\n"; " ") | .[0:80])"
    '
}

# ═══════════════════════════════════════════════════════════════════════════════
# OUTPUT FORMATTING
# ═══════════════════════════════════════════════════════════════════════════════

format_alert_markdown() {
  local alerts_json="$1"
  local alert_number="$2"
  local repo="$3"

  printf '%s\n' "$alerts_json" | jq -r --arg num "$alert_number" --arg repo "$repo" --arg org "$ORG" '
        .[] | select(.number == ($num | tonumber)) |
        "# Dependabot Alert: \($repo) #\($num)\n\n" +
        "| Field | Value |\n" +
        "|-------|-------|\n" +
        "| **Package** | `\(.security_vulnerability.package.name)` |\n" +
        "| **Ecosystem** | \(.security_vulnerability.package.ecosystem) |\n" +
        "| **Severity** | **\(.security_advisory.severity | ascii_upcase)** |\n" +
        "| **CVE** | \(.security_advisory.cve_id // "N/A") |\n" +
        "| **GHSA** | \(.security_advisory.ghsa_id // "N/A") |\n" +
        "| **State** | \(.state) |\n" +
        "| **Created** | \(.created_at) |\n\n" +
        "## Vulnerability\n\n" +
        "\(.security_advisory.summary)\n\n" +
        "\(.security_advisory.description | split("\n") | .[0:10] | join("\n"))\n\n" +
        "## Affected Versions\n\n" +
        "`\(.security_vulnerability.vulnerable_version_range)`\n\n" +
        "## Fix\n\n" +
        (if .security_vulnerability.first_patched_version.identifier then
            "Upgrade to version `\(.security_vulnerability.first_patched_version.identifier)` or later"
        else
            "No fix available yet"
        end) + "\n\n" +
        "## Links\n\n" +
        "- [Alert](\(.html_url))\n" +
        "- [Advisory](https://github.com/advisories/\(.security_advisory.ghsa_id))\n"
    '
}

# ═══════════════════════════════════════════════════════════════════════════════
# NON-INTERACTIVE MODE
# ═══════════════════════════════════════════════════════════════════════════════

# Output all alerts for a repo as markdown table (non-interactive)
output_repo_summary() {
  local repo="$1"

  local alerts_json
  alerts_json=$(fetch_repo_alerts "$repo")

  if [ -z "$alerts_json" ] || [ "$alerts_json" = "null" ]; then
    error "No alerts found for repository: ${repo}"
  fi

  # Output markdown table
  printf '%s\n' "$alerts_json" | jq -r --arg repo "$repo" '
        "# Dependabot Alerts: \($repo)\n\n" +
        "| # | Severity | Package | CVE/GHSA | Fix | Summary |\n" +
        "|---|----------|---------|----------|-----|---------|" ,
        (.[] |
            "| \(.number) | **\(.security_advisory.severity | ascii_upcase)** | `\(.security_vulnerability.package.name)` | \(.security_advisory.cve_id // .security_advisory.ghsa_id // "N/A") | \(if .security_vulnerability.first_patched_version.identifier then "`\(.security_vulnerability.first_patched_version.identifier)`" else "None" end) | \(.security_advisory.summary | gsub("\n"; " ") | .[0:60])\(.security_advisory.summary | if length > 60 then "..." else "" end) |"
        )
    '
}

# Output a specific alert (non-interactive, no clipboard)
output_alert() {
  local repo="$1"
  local alert_number="$2"

  local alerts_json
  alerts_json=$(fetch_repo_alerts "$repo")

  if [ -z "$alerts_json" ] || [ "$alerts_json" = "null" ]; then
    error "No alerts found for repository: ${repo}"
  fi

  local formatted_alert
  formatted_alert=$(format_alert_markdown "$alerts_json" "$alert_number" "$repo")

  if [ -z "$formatted_alert" ]; then
    error "Alert #${alert_number} not found in repository: ${repo}"
  fi

  # Output to stdout (no clipboard copy)
  echo "$formatted_alert"
}

# ═══════════════════════════════════════════════════════════════════════════════
# MAIN WORKFLOW
# ═══════════════════════════════════════════════════════════════════════════════

# Select repository and set SELECTED_REPO global variable
select_repository() {
  local alerts_json="$1"
  local repos_data

  SELECTED_REPO=""

  repos_data=$(get_repos_with_counts "$alerts_json")

  if [ -z "$repos_data" ]; then
    success "No open Dependabot alerts found for ${ORG}!"
    exit 0
  fi

  echo ""
  echo -e "${BOLD}${CYAN}Select a repository to view alerts:${NC}"
  echo ""

  # Build display list for fzf
  local display_list=""
  while IFS= read -r line; do
    local repo total critical high medium low
    IFS='|' read -r repo total critical high medium low <<<"$line"

    local severity_info=""
    [ "$critical" -gt 0 ] && severity_info+="$critical critical  "
    [ "$high" -gt 0 ] && severity_info+="$high high  "
    [ "$medium" -gt 0 ] && severity_info+="$medium medium  "
    [ "$low" -gt 0 ] && severity_info+="$low low"

    display_list+=$(printf "%-40s  (%d alerts)  %s" "$repo" "$total" "$severity_info")
    display_list+=$'\n'
  done <<<"$repos_data"

  local selected
  # Use || true to prevent set -e from exiting if user cancels fzf
  selected=$(echo "$display_list" | fzf \
    --header="Repositories with Dependabot Alerts (Enter to select, Ctrl+C to exit)" \
    --height=50% \
    --border=rounded \
    --prompt="Filter: " \
    --pointer="▶" \
    --marker="●" \
    --color="header:cyan,pointer:magenta,marker:green,prompt:blue") || true

  if [ -z "$selected" ]; then
    info "No repository selected. Exiting."
    exit 0
  fi

  # Extract repo name (first field) and set global variable
  SELECTED_REPO=$(echo "$selected" | awk '{print $1}')
}

select_alert() {
  local repo="$1"
  local alerts_json

  info "Fetching alerts for ${CYAN}${repo}${NC}..."
  alerts_json=$(fetch_repo_alerts "$repo")

  if [ -z "$alerts_json" ] || [ "$alerts_json" = "null" ]; then
    warn "No alerts found for ${repo}"
    exit 0
  fi

  local alert_summaries
  alert_summaries=$(format_alert_summaries "$alerts_json")

  if [ -z "$alert_summaries" ]; then
    warn "No alerts found for ${repo}"
    exit 0
  fi

  echo ""
  echo -e "${BOLD}${CYAN}Select an alert to view details:${NC}"
  echo ""

  # Build display list for fzf
  local display_list=""
  while IFS= read -r line; do
    local number severity package cve summary
    IFS='|' read -r number severity package cve summary <<<"$line"

    local sev_display
    case "${severity,,}" in
    critical) sev_display="CRITICAL" ;;
    high) sev_display="HIGH    " ;;
    medium) sev_display="MEDIUM  " ;;
    low) sev_display="LOW     " ;;
    *) sev_display="UNKNOWN " ;;
    esac

    display_list+=$(printf "#%-4s [%s] %-30s %s - %s" "$number" "$sev_display" "$package" "$cve" "$summary")
    display_list+=$'\n'
  done <<<"$alert_summaries"

  local selected
  # Use || true to prevent set -e from exiting if user cancels fzf
  selected=$(echo "$display_list" | fzf \
    --header="Alerts for ${repo} (Enter to select and copy, Ctrl+C to exit)" \
    --height=60% \
    --border=rounded \
    --prompt="Filter: " \
    --pointer="▶" \
    --marker="●" \
    --preview-window=down:40%:wrap \
    --color="header:cyan,pointer:magenta,marker:green,prompt:blue") || true

  if [ -z "$selected" ]; then
    info "No alert selected. Exiting."
    exit 0
  fi

  # Extract alert number
  local alert_number
  alert_number=$(echo "$selected" | sed 's/^#//' | awk '{print $1}')

  # Format and copy to clipboard
  local formatted_alert
  formatted_alert=$(format_alert_markdown "$alerts_json" "$alert_number" "$repo")

  echo "$formatted_alert" | pbcopy

  echo ""
  echo -e "${GREEN}Alert details copied to clipboard!${NC}"
  echo ""
  echo -e "${BOLD}Preview:${NC}"
  echo ""
  echo "$formatted_alert"
  echo ""
}

main() {
  local arg_repo=""
  local arg_alert=""

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
    -h | --help)
      show_help
      exit 0
      ;;
    -r | --repo)
      if [[ -z "${2:-}" ]]; then
        error "--repo requires a repository name"
      fi
      arg_repo="$2"
      shift
      ;;
    -a | --alert)
      if [[ -z "${2:-}" ]]; then
        error "--alert requires an alert number"
      fi
      arg_alert="$2"
      shift
      ;;
    *)
      error "Unknown option: $1\nUse --help for usage information."
      ;;
    esac
    shift
  done

  # Validate arguments
  if [ -n "$arg_alert" ] && [ -z "$arg_repo" ]; then
    error "--alert requires --repo to be specified"
  fi

  # Determine mode and check dependencies
  local interactive_mode="true"
  if [ -n "$arg_repo" ]; then
    interactive_mode="false"
  fi

  check_dependencies "$interactive_mode"

  # Non-interactive mode: output specific alert
  if [ -n "$arg_repo" ] && [ -n "$arg_alert" ]; then
    output_alert "$arg_repo" "$arg_alert"
    exit 0
  fi

  # Non-interactive mode: output repo summary table
  if [ -n "$arg_repo" ]; then
    output_repo_summary "$arg_repo"
    exit 0
  fi

  # Interactive mode: show banner
  echo ""
  echo -e "${BOLD}${MAGENTA}╔═══════════════════════════════════════════════════════════════════════════════╗${NC}"
  echo -e "${BOLD}${MAGENTA}║              Dependabot Alert Viewer - ${ORG}                          ║${NC}"
  echo -e "${BOLD}${MAGENTA}╚═══════════════════════════════════════════════════════════════════════════════╝${NC}"
  echo ""

  # Fully interactive mode: select repo then alert
  local org_alerts
  org_alerts=$(fetch_org_alerts)

  # Check if we got any alerts
  if [ "$(printf '%s\n' "$org_alerts" | jq 'length')" -eq 0 ]; then
    success "No open Dependabot alerts found for ${ORG}!"
    exit 0
  fi

  # Select repository (sets SELECTED_REPO global variable)
  select_repository "$org_alerts"

  # Select and display alert
  select_alert "$SELECTED_REPO"
}

# Run main function
main "$@"
